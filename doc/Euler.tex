\documentclass[oneside,12pt]{book}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{savesym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{epigraph}
\setlength{\epigraphwidth}{4.1in}

\usepackage{makeidx}
\usepackage{microtype}
\usepackage{fancyhdr}
	\fancyhead{}
	\fancyfoot{}
%\renewcommand{\headrulewidth}{0pt}
	\fancyhead[EL, OR]{\thepage}
	\fancyhead[CO]{\rightmark}
	\fancyhead[CE]{\leftmark}
\pagestyle{fancy}

\usepackage[mathscr]{eucal}
\usepackage{setspace}
\usepackage{caption}
\usepackage[pdftex]{graphicx}
\usepackage[perpage,symbol*,norule,multiple,hang,bottom]{footmisc}
\usepackage{pdftricks}
\usepackage[basic,box,gate,oldgate,ic,physics,optics]{circ}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{ifthen}
\usepackage{courier}
\usepackage[pdftex,bookmarks=true,pdfborder={0 0 0},colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage[all]{hypcap}
\usepackage{lscape}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows}
\usepackage[h]{esvect}
\usepackage[T1]{fontenc}
\usepackage{frcursive}
\usepackage{polynom}

%\usepackage{tocloft}
%\setlength{\cftchapnumwidth}{2.5em}
%\setlength{\cftsecnumwidth}{2.7em}
%\setlength{\cftsubsecnumwidth}{4.0em}
%\setlength{\cftsubsubsecnumwidth}{4.1em}
%\setlength{\cftparanumwidth}{5 em}
%\setlength{\cftsubparanumwidth}{6 em}

\usepackage{enumitem}
\usepackage{placeins}
\newenvironment{callseries}{\fontfamily{calligra}\selectfont}{}
\newcommand{\textcall}[1]{{\callseries#1}}
\usepackage{fp}
\usepackage{forloop}

\makeindex

\newcounter{ex}
\newcounter{def}
\newcounter{pr}
\newtheorem{axiom}{Axiom}[section]
\newtheorem{problem}{Problem}
\newtheorem{thm}{Theorem}[chapter]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Property}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{claim}[thm]{Claim}

\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{algo}[thm]{Alogithm}
\newtheorem{rem}[thm]{Remark}
\newtheorem{exam}[thm]{Example}
\newtheorem{notation}[thm]{Notation}
\newtheorem{idn}[thm]{Identity}


\newcommand{\adj}[1]{\mathrm{adj }~#1}
%\newcommand{\R}[1]{\mathbb{R}^{#1}}
\newcommand{\nul}[1]{\mathrm{nul }~#1}
\newcommand{\col}[1]{\mathrm{col }~#1}
\newcommand{\Span}[1]{\mathrm{Span }\left\{#1\right\}}
\newcommand{\Dim}[1]{\mathrm{dim }~#1}
\newcommand{\Null}[1]{\mathrm{null }~#1}
\newcommand{\Rank}[1]{\mathrm{rank }~#1}
\newcommand{\Range}[1]{\mathrm{range }~#1}
\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\dist}[1]{\mathrm{dist }#1}
\newcommand{\norm}[1]{|\B{#1}|}
\newcommand{\cross}[2]{\vv{#1}\times\vv{#2}}
\newcommand{\dotp}[2]{\vec{#1}\cdot\vec{#2}}

\newcommand{\StirlingTwo}[2]{\genfrac{\{}{\}}{0pt}{}{#1}{#2}}
\newcommand{\StirlingOne}[2]{\genfrac{[}{]}{0pt}{}{#1}{#2}}

\newcommand{\lcm}[1]{\mathrm{lcm }#1}
\newcommand{\p}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pp}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\newcommand{\diff}[2]{\frac{d #1}{d #2}}
\newcommand{\Diff}[3]{#1^{(#2)}(#3)}
\newcommand{\del}[0]{\nabla}
\newcommand{\mref}[1]{\ifmathematics \ref{#1} \fi}
\newcommand{\ipv}[2]{\langle\vv{#1},\vv{#2}\rangle}
\newcommand{\ip}[2]{\langle#1,#2\rangle}
\newcommand{\vnorm}[1]{\left|\left|\vv{#1}\right|\right|}
\newcommand{\lnorm}[1]{\left|\left|#1\right|\right|}
\newcommand{\Res}[1]{\mathrm{Res }(#1)}
\newcommand{\Log}[1]{\mathrm{Log }{#1}}

\savesymbol{triangleleft}
\savesymbol{trianglelefteq}
% wide symbols, but mangles triangles. 
\usepackage{mathabx}
\newcommand{\normal}[0]{\triangleleft}
\restoresymbol{ABX}{triangleleft}
\restoresymbol{ABX}{trianglelefteq}

\newcommand{\image}[1]{\mathrm{Im\ }#1}
\newcommand{\vaprhi}[0]{\varphi}
\newcommand{\kernel}[0]{\mathrm{Kern\ }}
\newcommand{\stab}[2]{\mathrm{Stab}_{#1}\left(#2\right)}
\newcommand{\Arg}[0]{\mathrm{Arg\ }}
\newcommand{\orb}[2]{\mathrm{Orb}_{#1}\left(#2\right)}
\newcommand{\aut}[1]{\mathrm{Aut}(#1)}
\newcommand{\inn}[1]{\mathrm{Inn}(#1)}
\newcommand{\syl}[2]{\mathrm{Syl}_{#1}\left(#2\right)}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\charsg}[0]{\mathrm{\ char\ }}
\newcommand{\card}[1]{\mbox{card }#1}
\newcommand{\seg}[1]{\mbox{seg }#1}

\newcommand{\Lor}[0]{\vee}
\newcommand{\Land}[0]{\wedge}
\newcommand{\disjointunion}[0]{\sqcup}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceiling}[1]{\lceil #1 \rceil}

\newcommand{\dom}[0]{\mbox{dom}~}
\newcommand{\ran}[0]{\mbox{ran}~}

\newcommand{\order}[1]{\left| #1 \right|}

\lstset{rangeprefix=\/\/\ ,rangesuffix=\ \/\/}
\lstset{
	xleftmargin=5.0ex,
	firstnumber=1,
	includerangemarker=false,
	numbers=left,
	numberstyle=\tiny,
	language=C,
	frame=single,
	columns=fixed,
	breaklines=true,
	basicstyle=\footnotesize,
	tabsize=4
}

\renewcommand{\footnoterule}{
	\kern -3pt
	\hrule width \textwidth height 0.4pt
	\kern 2.6 pt
}

\title{Project Euler Problems}
\author{Michael E. Conlen}
%\date{}							% Activate to display a given date or no date

\begin{document}
\begin{spacing}{1.618}
\frontmatter
\maketitle

\chapter*{Preface}

Project Euler, \url{http://projecteuler.net/}, is a list of programming problems with a mathematical and algorithmic bent. These problems have solutions that vary from the na\"ive to the sophisticated. While the easiest problems can be effectively solved na\"ively the advanced problems require sophisticated solutions to run effectively. Here we compile a set of solutions in various programming languages along with a mathematical treatment of the sophisticated solutions. Where possible the solutions are generalized for various parameters given in the statement of the problem. 

While Project Euler requests that the solutions not be shared outside of the forums it's clear the solutions are available on the internet. If you have not solved a problem it is up to you to be honest. It is up to  you to realize that understanding the solution is not the point; the point is to have been able to develop the solution yourself. 

\tableofcontents
\lstlistoflistings
\mainmatter

	\chapter{Sum of Natural Numbers Divisible by 3 and 5}
			\begin{quote}
				If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

				Find the sum of all the multiples of 3 or 5 below 1000.
			\end{quote}

		\section{Introduction}
			
			The na\"ive solutions is to iterate $k$ over the range of integers and if $k\equiv 0\pmod 3$ or $k\equiv 0\pmod 5$ then add the integer to the sum. This solutions is given in Listing \ref{L:1:naive.c}; however this solution runs in $O(n)$ time. A direct computation can be found. 
\lstinputlisting[caption=Problem 1: Na\"ive Solution,label=L:1:naive.c,float=htp]{../src/lang/C/1-1.c}

		\section{Direct Computation}

			Let $n$ be the integer we iterate up through, in this case, $999$\footnote{The problem asks for numbers up to $1000$, thus does not include $1000$ where it is a multiple of $5$.}. Let $m_q=\floor{\frac{n}{q}}$, the number of natural numbers less than $n$ which are multiples of the natural number $q$; then notice that the sum of natural numbers less than $n$ and divisible by $q$ is  
			\begin{alignat}{4}
				q+2q+3q+\dots+m_q q&=q\sum_{k=1}^{m_q}k \notag \\
					&=q\frac{(m_q)(m_q+1)}{2}
			\end{alignat}
			
			If we are summing over the integers which are multiples of $q$ and $r$ then each natural number which is a multiple of both $p$ and $r$ is counted twice; thus we subtract multiples of $qr$; and the solution is 
			\begin{alignat}{4}
				q\frac{(m_q)(m_q+1)}{2}+r\frac{(m_r)(m_r+1)}{2}-qr\frac{(m_{qr})(m_{qr}+1)}{2}
			\end{alignat}
			A generalized version of this program is given in Listing \ref{L:1:1.c}. It's runtime is $O(1)$. 
			\lstinputlisting[caption=Problem 1: C Solution,label=L:1:1.c,float=htp]{../src/lang/C/1-2.c}
			 

	\chapter{Sum of Even Fibonacci Numbers}
		\begin{quote}
			Each new term in the Fibonacci\index{Fibonacci Number} sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

			\begin{alignat*}{4}
				1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \dots
			\end{alignat*}
			By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
		\end{quote}

		\section{Introduction}
		
			The na\"ive solution is to iterate $k$ over the range of natural numbers computing $F_k$, the $k^{th}$ Fibonacci number, until $F_k>4000000$ and if $F_k$ is even add it to the sum. This solution is given in Listing \ref{L:2:naive.c}. While this solution is generally quick on modern computers it is not efficient. 
			
			\lstinputlisting[caption=Problem 2: Na\"ive Solution,label=L:2:naive.c,float=htp]{../src/lang/C/2-1.c}
		\section{Order of $F_n$}
			We claim that the computation of \texttt{fib(n)} is at least exponential. Let $T(n)$ be the time to compute the $n^{th}$ Fibonacci number and we can see that if we let $T(0)=1$ in units of the time to make the comparison in Line 6, then $T(1)=2 > 1$ and $T(2)=2+T(1)+T(0)> T(1)+T(0)$. In general $T(n)> T(n-1)+T(n-2)$. That is, the estimate is directly related to the Fibonacci numbers themselves.
			
			We may use generating functions\index{generating function}\footnote{See \cite{Wilf2006,GKP94}.} to compute $F_k$. Assume there is a function $f(x)=\sum_{k=0}^\infty F_kx^k$. Recall the defining equation of the Fibonacci numbers;
			\begin{alignat}{4}
				F_{k+2}=F_{k+1}+F_k \label{E:2:1}
			\end{alignat}
			with the boundary conditions $F_0=0$ and $F_1=1$\footnote{This is not precisely the same boundary as $T(0)=1$ and $T(1)=1$; however we can see that it is simply a shift if we consider the negative extension $T(-1)=0$ noting that it preserves the recurrence relation. This preserves the standard numbering of the Fibonacci sequence.}. Multiply equation \ref{E:2:1} by $x^k$,
			\begin{alignat}{4}
				F_{k+2}x^k=F_{k+1}x^k+F_kx^k \label{E:2:2}
			\end{alignat}
			then sum both sides of equation \ref{E:2:2} over all $k$ and compute
			\begin{alignat}{4}
					&&\sum_{k=0}^\infty F_{k+2}x^k&=\sum_{k=0}^\infty F_{k+1}x^k +\sum_{k=0}^\infty F_kx^k \notag \\
				\implies &&\frac{1}{x^2}\sum_{k=0}^\infty F_{k+2}x^{k+2}&=\frac{1}{x}\sum_{k=0}^\infty F_{k+1}x^{k+1} +f(x) \notag \\
				\implies && \frac{1}{x^2}\left(f(x)-F_1x-F_0\right)&=\frac{1}{x}\left(f(x)-F_0\right) + f(x) \notag \\
				\implies && f(x)-F_1x-F_0&=x\left(f(x)-F_0\right)+x^2f(x) \notag \\
				\implies && f(x)-xf(x)-x^2f(x)&=F_1x+F_0-F_0x \notag \\
				\implies && f(x)\left(1-x-x^2\right)&=x \notag \\
				\implies && f(x)&=\frac{x}{1-x-x^2} \label{E:2:3}
			\end{alignat}
			
			If we define $\varphi=\frac{1+\sqrt{5}}{2}$ and $\psi=\frac{1-\sqrt{5}}{2}$ we can see that
			\begin{alignat}{4}
				1-x-x^2=(1-x\varphi)(1-x\psi) \label{E:2:4}
			\end{alignat}
			Thus we can simplify equation \ref{E:2:3} using equation \ref{E:2:4} and partial fraction decomposition
			\begin{alignat}{4}
				\frac{x}{1-x-x^2}&=\frac{x}{(1-x\varphi)(1-x\psi)} \notag \\
					&=\frac{A}{1-x\varphi}+\frac{B}{1+x\psi} \notag \\
					&=\frac{(1-x\psi)A+(1-x\varphi)B}{1-x-x^2} \notag \\
					&=\frac{(A+B)-x(\psi A+\varphi B)}{1-x-x^2} \label{E:2:5}
			\end{alignat}
			and from equation \ref{E:2:5} we can deduce that $A+B=0$ and $\psi A+\varphi B=1$ and compute
			\begin{alignat}{4}
				&&\psi A+\varphi B&=-1 \notag \\
				\implies && \psi A+ \varphi (-A)&=-1 \notag \\
				\implies && (\psi -\varphi) A &=-1 \notag \\
				\implies && A &=\frac{1}{\varphi-\psi} \notag 
			\end{alignat}
			thus
			\begin{alignat}{4}
				B&=-\frac{1}{\varphi-\psi} \notag
			\end{alignat}
			We rewrite equation \ref{E:2:3}
			\begin{alignat}{4}
				\frac{1}{1-x-x^2}&=\frac{1}{\varphi-\psi}\left(\frac{1}{1-x\varphi}-\frac{1}{1-x\psi}\right) \notag \\
					&=\frac{1}{\sqrt{5}}\left(\sum_{k=0}^\infty \varphi^kx^k - \sum_{k=0}^\infty \psi^kx^k\right) \notag \\
					&=\sum_{k=0}^\infty \frac{\varphi^k-\psi^k}{\sqrt{5}} x^k
			\end{alignat}
			thus, recalling that $f(x)=\sum_{k=0}^\infty F_kx^k$ we conclude that
			\begin{alignat}{4}
				F_k=\frac{\varphi^k-\psi^k}{\sqrt{5}} \label{E:2:7}
			\end{alignat}
			
			Since $\order{\psi}<1$ we have that $\psi^k\to 0$ as $k\to\infty$; thus we can see that $F_k$ is exponential in $k$; hence $T(n)$ is at least $O\left(\varphi^n\right)$\footnote{If we work with the estimate that $T_0=1$, $T_1=2$ and $T_{k+2}=T_{k+1}+T_k+m$ where $m$ is the number of operations for the non-recursive steps in the general case, then a similar analysis will show that the runtime is exponential.}. 
		
		\section{Computing \texttt{fib(n)} Directly}
		
			Equation \ref{E:2:7} gives us a closed form for $F_n$ which can be computed for the cost of two calls to \texttt{pow()}. Recall, however, that $\order{\psi}<1$ and, in fact, $\order{\frac{\psi}{\sqrt{5}}}<\frac{1}{2}$; thus we can avoid computation of $\psi^n$ and estimate that $F_k= \frac{\vaprhi^k}{\sqrt{5}}+\epsilon$ and that $\order{\epsilon}<1$; thus we can compute
			\begin{alignat}{4}
				F_k=\floor{\frac{\varphi^k}{\sqrt{5}}+\frac{1}{2}}
			\end{alignat}
			\lstinputlisting[caption=Problem 2: \texttt{fib(n)} Direct,label=L:2:1.c,float=htp]{../src/lang/C/2-2.c}
			This solution is given in Listing \ref{L:2:1.c}. Note that we make use of the fact that for positive numbers typecasting a \texttt{double} to an \texttt{int} type is equivalent to the floor function. In this implementation the runtime of \texttt{fib(n)} is generally $O(1)$ as \texttt{pow()} is implemented in constant time on most processors\footnote{If this is not available exponentiation by squaring is $O(\log n)$.}. This gives the overall program a runtime of $O(\log n)$; but we can do better. 
		
	\section{Sum of Even Fibonacci Numbers}
	
		Notice that the first two Fibonacci numbers are odd, followed by an even. We can see from the defining relation that the even Fibonacci numbers have an index $k\equiv 0\pmod 3$. Moreover, the sum of the even Fibonacci numbers is equal to the sum of the odd Fibonacci numbers before it. We can make use of this fact and the following observation
		\begin{thm}
			Let $F_k$ be the $k^{th}$ Fibonacci number with $F_1=1$ and $F_2=1$; then $\sum_{k=1}^n F_k=F_{n+2}-1$. 
			\begin{proof}[Solution]
				Let $n=1$ then $\sum_{k=1}^1F_k=F_1=1=2-1=F_3-1$; this proves the base case. 
				We compute for arbitrary $n$
				\begin{alignat}{4}
					\sum_{k=1}^nF_k&=F_n + \sum_{k=1}^{n-1}F_k  \notag \\
						&= F_n + F_{n+1} -1 \notag \\
						&= F_{n+2}-1 \notag 
				\end{alignat}
			\end{proof}
		\end{thm}	
		
		Thus, if we know the index of the largest Fibonacci number less than or equal to some value, we can compute the desired sum. 	
			
	\section{Finding the Index}
		
		Notice that if we have a Fibonacci number $F$, then we can compute the index into the sequence, $k$, by 
		\begin{alignat}{4}
			k=\log_\varphi{\left(F\sqrt{5}+\psi^k\right)} \notag
		\end{alignat}
		but without $k$ we must estimate, but $\order{\psi^k}<\frac{1}{2}$ for $k>1$; thus we have that 
		\begin{alignat}{4}
			k<\log_\varphi{\left(F\sqrt{5}+\frac{1}{2}\right)} \notag 
		\end{alignat}
		moreover, the difference is less than $1$ for sufficiently large $F$\footnote{Consider $\frac{d}{dx}\log{(x)}=\frac{1}{x}$.} so let 
		\begin{alignat}{4}
			k=\floor{\log_\varphi{\left(F\sqrt{5}+\frac{1}{2}\right)}} \notag
		\end{alignat}
		
		Now, suppose that $F$ is not a Fibonacci number, but is some natural number; then for some $j\in\mathbb{N}$, $F_j<F<F_{j+1}$ so 
		\begin{alignat}{4}
			j\leq\floor{\log_\varphi{\left(F\sqrt{5}+\frac{1}{2}\right)}}\leq j+1
		\end{alignat}
		thus
		\begin{alignat}{4}
			\floor{\log_\varphi{\left(F\sqrt{5}+\frac{1}{2}\right)}}\in \set{j, j+1}
		\end{alignat}
		We wish to determine $j$, the index of the largest Fibonacci number less than or equal to $F$\footnote{Recall that the problem states \emph{\dots terms in the Fibonacci sequence whose values do not exceed four million\dots}}; so compute $k$ then $F_k$ and if $k=j+1$ $F_k>F$ and if $k=j$ then $F_k\leq F$. In either case we can determine $j$. 
		
		Finally, to get the largest \emph{even} Fibonacci number recall that a Fibonacci number $F_k$ is even if and only if $k\equiv 0\pmod 3$. 

	\section{Direct Computation}

		We combine the results of the last two sections in Listing \ref{L:2:2.c}. 
	
		\lstinputlisting[caption=Problem 2: Direct Solution,label=L:2:2.c,float=htp]{../src/lang/C/2-3.c}

	\section{Generalization}
	
		We generalize the above solution to arbitrary $n$ within the limits of \texttt{unsigned long long} in Listing \ref{L:2:3.c}. 
		
		\lstinputlisting[caption=Problem 2: General Solution,label=L:2:3.c,float=htp]{../src/lang/C/2-4.c}

	\chapter{Largest Prime Factor of $n$}
		\epigraph{The problem of distinguishing prime numbers from composite numbers and of resolving the latter into their prime factors is known to be one of the mots important and useful in arithmetic}{C. F. Gauss}
		\begin{quote}
			The prime factors of 13195 are 5, 7, 13 and 29.

			What is the largest prime\index{prime} factor of the number 600851475143 ?
		\end{quote}
	
		\section{Introduction}
			This algorithm works simply by factoring the integer\footnote{See Appendix \ref{C:Factoring}.} in to prime factors then searching for the largest of the list.  We implement this algorithm in Listing \ref{L:3:naive.c}. 
			
			\lstinputlisting[caption=Problem 3: Na\"ive Solution,label=L:3:naive.c,float=htp]{../src/lang/C/3-1.c}
		
		\section{Remarks}
		
			There are a number of more efficient algorithms for larger composite numbers to investigate including the general number sieve. 

	\chapter{Largest Palindrome Product}
	
		\begin{quote}
			A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is $9009 = 91\times 99$.

			Find the largest palindrome made from the product of two 3-digit numbers.
		\end{quote}
		
		\section{Introduction}
	
			This problem presents a few programming issues, the first is to factor an integer and find products of the factors of a given decimal size. The other problem is to be able to represent the sequence of palindrome numbers in a way that we can easily find the predecessor of an element in the sequence.
			
		\section{Palindromic Numbers}
		
			\subsection{Introduction}
				Palindromic numbers\index{palindromic number} are natural numbers which are the same when written (in a given base) forwards and reverse. These numbers can be thought of as having two varieties; those with an odd number of digits and those with an even number of digits.  We can represent a palindromic number by an integer, representing the leading sequence of the integer and a value to indicate whether the number of digits is odd or even; that is, whether the last digit in the integer should be included once or twice respectively. By way of example the palindromic number $10101$ can be represented by $(101, \mathtt{ODD})$ and the number $457754$ can be represented by $(457, \mathtt{EVEN})$. 
		
			\subsection{Predecessor and Successor}	
				To see how to compute predecessor or successor palindromic numbers we consider what the sequence looks like in these terms. The first nine terms are the natural numbers $0$ through $9$. These are represented by the values $(0, \mathtt{ODD})$ through $(9, \mathtt{ODD})$. These numbers are followed by $11, 22, 33, \dots, 99$ which are represented by $(1, \mathtt{EVEN})$ through $(9, \mathtt{EVEN})$. The next portion of the sequence is 
				\begin{alignat*}{4}
					101, 111, 121, 131, \dots, 191, 202, 212, 222, \dots, 292, 303, \dots, 999
				\end{alignat*}
				These are represented by $(10, \mathtt{ODD})$ through $(99, \mathtt{ODD})$. It can be seen that the following portion of the sequence is represented by the values $(10, \mathtt{EVEN})$ through $(99, \mathtt{EVEN})$. 
			
				We can then consider how to compute the successor of a given palindromic number $(a, b)$, written $(a, b)++$. If $a+1\neq 10^k$ for $k\in \mathbb{N}$, $k>0$ then $(a+b)++=(a+1, b)$. That is, $(7, \mathtt{ODD})++=(8, \mathtt{ODD})$ for example. If $a+1=10^k$ for $k\in\mathbb{N}$ and $k>0$ then we have two situations depending on $b$. The successor of $(9, \mathtt{ODD})$ is $(1, \mathtt{EVEN})$, likewise $(99, \mathtt{ODD})++=(10, \mathtt{EVEN})$ and so forth; thus we see that in this case 
				\begin{alignat*}{4}
					(a, b)++=\left(\frac{a+1}{10}, \mathtt{EVEN}\right)
				\end{alignat*}
				In the case where $b=\mathtt{EVEN}$ we have $(a, b)++=(a+1, \mathtt{ODD})$. 
			
				We can write the successor function as 
				\begin{alignat}{4}
					(a, b)++=\left\{\begin{array}{ll}
						(a+1, b),&a+1\neq 10^k,~k\in\mathbb{N},~k>0 \\
						\left(\frac{a+1}{10}, \mathtt{EVEN}\right),&a+1=10^k,~k\in\mathbb{N},~k>0\Land b=\mathtt{ODD} \\
						\left(a+1, \mathtt{ODD}\right),&a+1=10^k,~k\in\mathbb{N},k>0\Land b=\mathtt{EVEN}
					\end{array}\right.
				\end{alignat}
				This function is implemented in \texttt{palindromeSuccessor()} given in Listing \ref{L:palindrome:palindromeSuccessor}. 
				\lstinputlisting[linerange=palindromeSuccessor-end\ palindromeSuccessor,caption=Problem 4: \texttt{palindromeSuccessor()},label=L:palindrome:palindromeSuccessor,float=]{../src/lang/C/palindrome.c}
				
				From the successor we can compute the predecessor function $(a,b)--$, remembering to take care of a  few extra special cases. 
				\begin{alignat}{4}
					(a,b)--=\left\{\begin{array}{ll}
						\mathtt{UNDEFINED},&a=0\Land b=\mathtt{ODD} \\
						\left(a-1, \mathtt{ODD}\right),&a=1\Land b=\mathtt{ODD} \\
						(a-1, b),&a\neq 10^k,k\in\mathbb{N},k>0 \\
						\left(a-1, \mathtt{EVEN}\right),&a=10^k,k\in\mathbb{N},k>0\Land b=\mathtt{ODD} \\
						\left(\left(a-1\right)\cdot 10+9, \mathtt{ODD}\right),&a=10^k,k\in\mathbb{N}\Land b=\mathtt{EVEN}
					\end{array}\right.
				\end{alignat}

				\lstinputlisting[linerange=palindromePredecessor-end\ palindromePredecessor,caption=Problem 4: \texttt{palindromePredecessor()},label=L:palindrome:palindromePredecessor,float=]{../src/lang/C/palindrome.c}

			\subsection{Computing Integer from Representation}
			
				Given the representation of a palindromic number used above we need to compute the actual integer. The value $a$ represents the leading digits which must be shifted some places to the left. The number of places depends on the value of $b$. If $b=\mathtt{ODD}$ then the shift is $\floor{\log_{10}(a)}$. If $b=\mathtt{EVEN}$ then the shift is $\floor{\log_{10}(a)}+1$. 
				
				We might attempt to figure out the value of each place in decimal; but this has been done already by \texttt{sprintf()}. We simply determine the length of $a$, $\mathtt{digits}(a)=\floor{\log_{10}(a)}+1$ to determine the length of the string necessary, $\mathtt{length}(a)+1$, then use \texttt{sprintf()} to place the integer into the string, then treating each character as an integer subtract the value of the string "0" from each value. 
				
				The function \texttt{palindromeInteger()} in Listing \ref{L:palindrome:palindromeInteger} implements this. 
				
				\lstinputlisting[linerange=palindromeInteger-end\ palindromeInteger,caption=Problem 4: \texttt{palindromeInteger()},label=L:palindrome:palindromeInteger,float=]{../src/lang/C/palindrome.c}

			\subsection{Finding an Answer}
			
				Given that we can find the largest palindromic integer less than a given number\footnote{Using the free digits at the start of the integer find the palindromic integer associated with it. Either it satisfies the inequality, at which point any palindromic integer larger than it will not satisfy the inequality, or it's predecessor will satisfy the inequality.} we must determine if it satisfies the condition that it is the product of two integers of a given length. To do this we may start by factoring the integer into a list of $m$ prime factors. Then we can determine if any grouping of the prime factors into to integers will have products of the required length. There are $\sum_{k=0}^m\binom{m}{k}=2^m$ ways to group $m$ prime factors into two groups where we choose $k$ of them for one product and the remaining $m-k$ are in the other product. By enumerating over these $2^m$ groupings we can determine if any grouping satisfies by computation. 
				\lstinputlisting[linerange=twoFactor-end\ twoFactor,caption=Problem 4: \texttt{twoFactor()},label=L:factor:twoFactor,float=htp]{../src/lang/C/factor.c}
				
				This algorithm appears inefficient, possibly even exponential, at first glance; however it should not be too bad. Let $n$ be given. We may write $n=\prod_p p^{k_p}$ where $p$ ranges over all prime numbers and $k_p=0$ if $p\not\mid n$. The number of prime factors $m(n)$ is given by $m(n)=\sum k_p$. We can understand the growth of $m$ by inverting it. The smallest integer which has $x$ prime factors is $2^x$ since any integer which has as many prime factors must have some factor(s) which are not $2$ and all prime numbers not equal to $2$ are greater than $2$. $m\left(2^x\right)=x$; thus the growth of $m$ is $\log_2(n)$; thus an upper bound on the number of groupings we must check for each $n$ is $2^{\log_2(n)}=n$. Summing over all $n$ we have that the algorithm is $O\left(n^2\right)$. 
				
				The function \texttt{twoFactor()} takes a list of (presumably prime) factors and an integer $n$ such that $2^n$ is less than the length of the list and groups the prime factors. The code is given in Listing \ref{L:factor:twoFactor}. 

				In short, the algorithm is as follows
				\begin{enumerate}
					\item	Find largest palindromic number less than $999\times 999$
					\item	For each palindromic number less than $999\times 999$ down to $100\times 100$ do:
						\begin{enumerate}
							\item Factor the palindromic integer
							\item For each grouping of the factors determine if the grouping results in a pair of $3$-digit numbers; if so terminate 
						\end{enumerate}
				\end{enumerate}
				The code for this is given in Listing \ref{L:4-1.c}
				\begin{spacing}{1}
				\lstinputlisting[caption=Problem 4: \texttt{main()},label=L:4-1.c,]{../src/lang/C/4-1.c}
				\end{spacing}
\appendix
	\chapter{Factoring Integers}\label{C:Factoring}
		\section{Introduction}
		
			Factoring integers is a key component of several problems; therefore a factoring library exists to factor integers and return a list of the prime factors. The header, \texttt{factor.h}, is given in listing \ref{L:factor:factor.h}.  The code in \texttt{factor.c} is given in listing \ref{L:factor:factor.c}. 
		
		\section{\texttt{factorN()}}
		
			The function \texttt{factorN()} works by finding small factors, factoring them out and continuing to look for successively larger factors.
		
			More precisely, let $n\in \mathbb{N}$ be given. Let $n_1=n$. Let $m_2\in\mathbb{N}$ be the largest number such that $2^{m_2}$ divides $n_1$; then set $n_2=\frac{n_1}{2^{m_2}}$. Inductively continue until we have a number $n_k$ such that $k>\sqrt{n_k}$. Since $\set{n_i}$ is a non-decreasing sequence this number $k$ exists. $n_k$ will then be the largest prime factor of $n$. 
			
			Clearly $n_k\mid n$. We can see that $n_k$ is not composite, since if it was the factors of $n_k$ would be smaller than $n_k$ and thus would have been divided out of $n_k$ at the appropriate step in the construction. We are left to show that there is no prime $p$ such that $p>n_k$ and $p\mid n$. This can be seen by looking at the sequence $\set{n_k}$. At each step where $n_k$ is a composite then at least one of it's prime factors is less than $\sqrt{n_k}$; thus, if there are no such prime factors then $n_k$ is prime. 

		\lstinputlisting[caption=\texttt{factor.h},label=L:factor:factor.h,float=htp]{../src/lang/C/factor.h}

		\lstinputlisting[linerange=factorN-end\ factorN,caption=\texttt{factor.c:factorN()},label=L:factor:factor.c,float=htp]{../src/lang/C/factor.c}

	
	\bibliography{Euler}
	\bibliographystyle{ieeetr}	
	\printindex
\end{spacing}
\end{document}  